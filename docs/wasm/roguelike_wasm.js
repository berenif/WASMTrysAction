// Placeholder for the WASM module
// This file should be generated by running:
// cd roguelike-wasm && wasm-pack build --target web --out-dir ../docs/wasm

// Mock implementation for testing
export class Game {
    constructor() {
        this.mapWidth = 50;
        this.mapHeight = 30;
        this.floor = 1;
        this.score = 0;
        this.gameOver = false;
        this.player = {
            x: 25,
            y: 15,
            health: 100,
            maxHealth: 100
        };
        this.messages = ["Welcome to the Roguelike Dungeon!"];
        this.map = [];
        this.explored = [];
        this.visible = [];
        
        // Initialize map
        for (let y = 0; y < this.mapHeight; y++) {
            this.map[y] = [];
            this.explored[y] = [];
            this.visible[y] = [];
            for (let x = 0; x < this.mapWidth; x++) {
                // Create walls around edges
                if (x === 0 || x === this.mapWidth - 1 || y === 0 || y === this.mapHeight - 1) {
                    this.map[y][x] = TileType.Wall;
                } else {
                    this.map[y][x] = TileType.Floor;
                }
                this.explored[y][x] = false;
                this.visible[y][x] = false;
            }
        }
        
        // Set initial visibility
        this.updateVisibility();
    }
    
    get_map_width() {
        return this.mapWidth;
    }
    
    get_map_height() {
        return this.mapHeight;
    }
    
    get_floor() {
        return this.floor;
    }
    
    get_score() {
        return this.score;
    }
    
    get_player() {
        return {
            get_x: () => this.player.x,
            get_y: () => this.player.y,
            get_health: () => this.player.health,
            get_max_health: () => this.player.maxHealth
        };
    }
    
    get_messages() {
        return this.messages;
    }
    
    get_tile(x, y) {
        if (x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight) {
            return this.map[y][x];
        }
        return TileType.Wall;
    }
    
    is_visible(x, y) {
        if (x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight) {
            return this.visible[y][x];
        }
        return false;
    }
    
    is_explored(x, y) {
        if (x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight) {
            return this.explored[y][x];
        }
        return false;
    }
    
    is_game_over() {
        return this.gameOver;
    }
    
    move_player(dx, dy) {
        const newX = this.player.x + dx;
        const newY = this.player.y + dy;
        
        if (newX > 0 && newX < this.mapWidth - 1 && 
            newY > 0 && newY < this.mapHeight - 1 &&
            this.map[newY][newX] !== TileType.Wall) {
            this.player.x = newX;
            this.player.y = newY;
            this.updateVisibility();
            this.messages.push(`You move to (${newX}, ${newY})`);
            return true;
        }
        return false;
    }
    
    get_entities_at(x, y) {
        const entities = [];
        if (x === this.player.x && y === this.player.y) {
            entities.push({
                get_type: () => EntityType.Player,
                get_symbol: () => '@'
            });
        }
        return entities;
    }
    
    updateVisibility() {
        // Simple visibility - just a radius around the player
        const radius = 8;
        
        // Clear visibility
        for (let y = 0; y < this.mapHeight; y++) {
            for (let x = 0; x < this.mapWidth; x++) {
                this.visible[y][x] = false;
            }
        }
        
        // Set visible tiles around player
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const x = this.player.x + dx;
                const y = this.player.y + dy;
                
                if (x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        this.visible[y][x] = true;
                        this.explored[y][x] = true;
                    }
                }
            }
        }
    }
}

export const TileType = {
    Wall: 0,
    Floor: 1,
    StairsDown: 2
};

export const EntityType = {
    Player: 0,
    Monster: 1,
    Gold: 2,
    Potion: 3
};

// Default export for initialization
export default async function init() {
    console.log("Mock WASM module initialized");
    return Promise.resolve();
}